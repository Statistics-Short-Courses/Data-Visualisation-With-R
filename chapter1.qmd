---
title: "Preparing Data for Tables"
format: 
  live-html:
    toc: true
resources: 
  - "Data-sets"
  
execute:
  echo: true
  warning: false
  message: false

webr:
  editor: true
  render-df: gt-interactive
    
embed-resources: true

filters:
  - custom-numbered-blocks

custom-numbered-blocks:
  classes:
    Assumption:
      colors: [FFCDD2, F44336]
      boxstyle: foldbox.simple
      collapse: false
    Example:
      colors: [BBDEFB, 2196F3]
      boxstyle: foldbox.simple
      collapse: false
    Exercise:
      colors: [C8E6C9, 4CAF50]
      boxstyle: foldbox.simple
      collapse: false
    Technical-point:
      colors: [FFF9C4, FFEB3B]
      boxstyle: foldbox.simple
      collapse: true
---

{{< include ./_extensions/r-wasm/live/_knitr.qmd >}}

{{< include ./_extensions/r-wasm/live/_gradethis.qmd >}}

Now that we've covered the main types of variables, we can start thinking about how to prepare and visually represent data with figures and tables. In this section, we will focus on preparing data for tables.

In R, datasets are stored as dataframes, which are objects made up of rows and columns. Each row corresponds to an individual observation, while each column represents the variable that is being measured. There are several ways R stores variables: character for text, factor for categorical, integer for whole numbers, numeric for decimals, and logical for booleans (TRUE/FALSE).

Cleaning data can be the most time-consuming, yet arguably the most important, part of analysing data! Generally, it is

-   wide format to long format

To understand R, we will examine these concepts using real-world datasets.

### NAPLAN

![](images/n-k-gWFW3TCdsps-unsplash.jpg){fig-align="center" width="490"}

*Photo by [N. K.](https://unsplash.com/@noybnk?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) on [Unsplash](https://unsplash.com/photos/brown-wooden-book-shelves-in-library-gWFW3TCdsps?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText)*

The first dataset to be explored is the NAPLAN dataset. NAPLAN stands for the National Assessment Program - Literacy and Numeracy, and is an annual national assessment for all students in year 3, 5, 7, and 9. The assessment is designed to evaluate whether students are building essential literacy and numeracy skills (https://www.nap.edu.au/naplan/faqs/naplan--general).

To load in the dataset, we can use the `read.csv()` function.

```{r, echo=FALSE, message=FALSE, warning=FALSE}
library(webexercises)
library(tidyverse)
```

```{r}
naplan <- read.csv("Data-sets/naplan_reading.csv")
```

Try typing this code yourself.

```{webr}
#| exercise: ex_1.1.0
#| envir: Ex1
#| warning: false
#| message: false

```

```{webr}
#| exercise: ex_1.1.0
#| solution: true
#| envir: Ex1
naplan <- read.csv("Data-sets/naplan_reading.csv")
```

```{webr}
#| exercise: ex_1.1.0
#| check: true
#| class: wait
#| envir: Ex1
gradethis::grade_this_code()
```

Now that we have the dataset loaded in, let's take a look at the variables in the dataset using `str()`.

```{webr}
#| exercise: ex_1.1.1
#| envir: Ex1
#| warning: false
#| message: false
# Call `str()` on the `naplan` dataset
str()
```

```{webr}
#| exercise: ex_1.1.1
#| solution: true
#| envir: Ex1
str(naplan)
```

```{webr}
#| exercise: ex_1.1.1
#| check: true
#| class: wait
#| envir: Ex1
gradethis::grade_this_code()
```

```{r, echo = FALSE, eval=FALSE}
str(naplan)
```

In the top line, we can see that there are 3000 observations and 11 variables.

We can confirm this using the `dim()` function

```{webr}
#| exercise: ex_1.1.2
#| envir: Ex1
#| warning: false
#| message: false
# Call `dim()` on the `naplan` dataset
```

```{webr}
#| exercise: ex_1.1.2
#| solution: true
#| envir: Ex1
dim(naplan)
```

```{webr}
#| exercise: ex_1.1.2
#| check: true
#| class: wait
#| envir: Ex1
gradethis::grade_this_code()
```

```{r, echo=FALSE, eval=FALSE}
dim(naplan)
```

Using the `names()` function, we can see the variable names.

```{webr}
#| exercise: ex_1.1.3
#| envir: Ex1
#| warning: false
#| message: false
# Call `names()` on the `naplan` dataset
```

```{webr}
#| exercise: ex_1.1.3
#| solution: true
#| envir: Ex1
names(naplan)
```

```{webr}
#| exercise: ex_1.1.3
#| check: true
#| class: wait
#| envir: Ex1
gradethis::grade_this_code()
```

```{r, echo=FALSE, eval=FALSE}
names(naplan)
```

The first column gives us the variables, the second column gives us the type of variable, and the third column gives us individual observations for each row. However, we can see `school_type` is stored as a `chr` or character (text) variable. Text variables are very common when you encounter surveys that have customer feedback, for example, as each response will be unique from one another.

It is important to check that your variables are stored correctly. We can see certain variables like reading time at home is an integer, which matches our expectations.

You can use the `unique()` function to see the unique groupings or labels within a categorical variable. In our case, we can use it to confirm if our suspicions that `school_type` is categorical. To call a specific variable, we call the dataset followed by `$` and then the variable name.

```{r}
unique(naplan$school_type)
```

There are only 3 unique labels, which strongly suggests that `school type` is a nominal categorical variable. If it were truly a text variable, we might see thousands of unique labels.

We can manually convert the variable to categorical using `as.factor()`:

```{r}
naplan$school_type <- as.factor(naplan$school_type)
```

```{r}
str(naplan)
```

Now we can see `school_type` is a factor with 3 levels (or 3 unique labels).

Alternatively, we can also convert all strings (text) to categorical variables with the `stringsAsFactors` argument when we read in the dataset.

```{r}
naplan <- read.csv("Data-sets/naplan_reading.csv",
                   stringsAsFactors = TRUE)
```

```{r}
str(naplan)
```

As seen above, all the `chr` variables have been converted to `Factor`, which is how the variables should be stored. Note that there might be times where you need a variable stored as `chr`, so you should always be sure of what you're checking.

We can now attach the dataset. Attaching the dataset means we can call variables directly without using `$`. For instance, we can call `school_type` directly as opposed to `naplan$school_type`.

```{r}
attach(naplan)
```

If we type `naplan` directly in, we can see the content.

```{r, eval=FALSE}
naplan
```

Alternatively, we can use the `View()` function to open up a new tab in RStudio with the dataset.

```{r,eval=FALSE}
View(naplan)
```

We can also select parts of the dataframe. This can be very useful for deciding which data you want to include a table. In R, we subset by calling the dataset followed by `[,]` . Writing a blank space before the comma indicates that all rows are includes, while a blank space after the comma indicates that all columns are included. For example, `[,3]` selects the third column of a dataframe. If we want to select the first three columns, we can write:

Try selecting the first three rows and first three columns of the `naplan` dataset. You select a number of rows or columns using `:`. For example, to select rows 3-4, simply type `naplan[3:4,]`

```{webr}
#| exercise: ex_1.1.4
#| envir: Ex1
#| warning: false
#| message: false
# Select the first three rows and three columns of the Naplan dataset
```

```{webr}
#| exercise: ex_1.1.4
#| solution: true
#| envir: Ex1
naplan[1:3,1:3]
```

```{webr}
#| exercise: ex_1.1.4
#| check: true
#| class: wait
#| envir: Ex1
gradethis::grade_this_code()
```

```{r, echo=FALSE, eval=FALSE}
# Select the first three rows and three columns of the Naplan dataset
naplan[1:3,1:3]
```

Now try selecting only rows 5-6.

```{webr}
#| exercise: ex_1.1.5
#| envir: Ex1
#| warning: false
#| message: false
# Select the fifth and sixth row of the Naplan dataset  

```

```{webr}
#| exercise: ex_1.1.5
#| solution: true
#| envir: Ex1
naplan[5:6,]
```

```{webr}
#| exercise: ex_1.1.5
#| check: true
#| class: wait
#| envir: Ex1
gradethis::grade_this_code()
```

```{r, echo=FALSE, eval=FALSE}
# Select the fifth and sixth row of the Naplan dataset 
naplan[5:6,]
```

We can even select rows based on logical tests on the values of one or more variables.

For instance, let's say we want all observations where reading time is greater than 45 mins. We can do this by typing `naplan[reading_time_home>45, ]`.

Try having a go below by selecting rows with reading times greater than 30 mins AND where students havea reading score greater than 800. Hint; you will need to use the logical operator `&`

```{webr}
#| exercise: ex_1.1.6
#| envir: Ex1
#| warning: false
#| message: false
# Select all rows (observations) that have a reading time at 
# home greater than 30 mins AND a naplan reading score greater than 800
# Hint; you will need to use the logical operator `&`

```

```{webr}
#| exercise: ex_1.1.6
#| solution: true
#| envir: Ex1
naplan[reading_time_home > 30 & naplan_reading_score > 860,]
```

```{webr}
#| exercise: ex_1.1.6
#| check: true
#| class: wait
#| envir: Ex1
gradethis::grade_this_code()
```

```{r, echo=FALSE, eval=FALSE}
# Select all rows (observations) that have a reading time at 
# home greater than 30 mins and a naplan reading score greater than 800
naplan[reading_time_home > 30 & naplan_reading_score > 860,]
```

The `dyplr` package can simplify this process. Some helpful functions include `select`, `mutate`, and `filter`. You can load in `tidyverse` which has `dplyr` built in, or load in `dyplr` directly.

```{r, eval=FALSE}
library(tidyverse)
```

Let's filter our data by Year 3 students with reading times at home above 100 mins.

```{r}
naplan %>%
  filter(grade == "Year 3" & reading_time_home > 100)
```

As we saw above, `student_id` and `school_id` is stored as integers. As these numbers actually represent unique labels, they should be treated as categorical. We can `mutate` `student_id` and `school_id` to `factor` variables.

```{r}
naplan <- naplan %>%
  mutate(across(c(school_id, student_id), as.factor))
```

```{r}
str(naplan)
```

We can combine several of these pipelines together. For example, we can `select` `student_id` and `school_id`, rename `student_id` to `student` and `school_id` to `school`, then `mutate` them back to integers and store the result in a new dataset called `naplan_new`.

```{r}
naplan_new <- naplan %>%
  select(student = student_id,
         school = school_id) %>%
  mutate(across(c(school, student), as.integer))

str(naplan_new)
```

We can summarise the content of the dataframe as well.

```{r}
summary(naplan)
```

You might notice that the summary doesn't quite work for categorical variables.

We can use `tapply()` and `with()` to summarise a quantitative variable by a qualitative variable.

```{r}
with(naplan, tapply(naplan_reading_score, grade, mean))
```

`aggregate()` allows you to summarise by one or more categorical variables, while `tapply` can only summarise one variable at a time.

```{r}
aggregate(naplan[,c(4,11)], list(grade),mean)
```

```{r}
aggregate(naplan[,c(4,11)], list(Grade = grade),mean)
```

```{r}
aggregate(naplan[,c(4,11)], list(Grade = grade, "Parent Education" = parent_education),mean)
```

### Exercise: Palmer Penguins

![](images/derek-oyen-3Xd5j9-drDA-unsplash%20(1).jpg){fig-align="center" width="542"}

*Photo by [Derek Oyen](https://unsplash.com/@goosegrease?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) on [Unsplash](https://unsplash.com/photos/penguins-on-snow-covered-fields-during-daytime-3Xd5j9-drDA?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText)*

First, we will need to load in some data into R. We will be working with the `palmerpenguins` package. The `palmerpenguins` package is a dataset collected and made available by [Dr. Kristen Gorman](https://www.uaf.edu/cfos/people/faculty/detail/kristen-gorman.php) and the [Palmer Station, Antarctica LTER](https://pallter.marine.rutgers.edu/), a member of the [Long Term Ecological Research Network](https://lternet.edu/).

If you have not used this package before, you will need to install it first.

```{r, eval=FALSE}
install.packages("palmerpenguins")
```

Once installed, you will need to load the package into R.

```{r, warning = FALSE, echo=FALSE, message=FALSE}
library(palmerpenguins)
```

```{webr}
#| exercise: ex_1.2.1
#| envir: Ex1
#| warning: false
#| message: false
# Load in the `palmerpenguins` package
```

```{webr}
#| exercise: ex_1.2.1
#| solution: true
#| envir: Ex1
# Load in the `palmerpenguins` package
library(palmerpenguins)
```

```{webr}
#| exercise: ex_1.2.1
#| check: true
#| class: wait
#| envir: Ex1
gradethis::grade_this_code()
```

Now that we have the package installed, let's take a look at the variables in the dataset using `str()` on the `penguins` dataset.

```{webr}
#| exercise: ex_1.2.2
#| envir: Ex1
#| warning: false
#| message: false
# Call str() on `penguins`
```

```{webr}
#| exercise: ex_1.2.2
#| solution: true
#| envir: Ex1
# Call str() on `penguins`
str(penguins)
```

```{webr}
#| exercise: ex_1.2.2
#| check: true
#| class: wait
#| envir: Ex1
gradethis::grade_this_code()
```

```{r, echo=FALSE, eval=FALSE}
str(penguins)
```

You might notice that some values are listed as `NA`. This means there are missing observations. To check for missing values, try using the embedded any(is.na()) function.

```{webr}
#| exercise: ex_1.2.3
#| envir: Ex1
#| warning: false
#| message: false
# Try using any(is.na()) on the `penguins` dataset.
```

```{webr}
#| exercise: ex_1.2.3
#| solution: true
#| envir: Ex1
# Try using any(is.na()) on the `penguins` dataset.
any(is.na(penguins))
```

```{webr}
#| exercise: ex_1.2.3
#| check: true
#| class: wait
#| envir: Ex1
gradethis::grade_this_code()
```

```{r, echo=FALSE, eval=FALSE}
any(is.na(penguins))
```

Since this returns `TRUE`, we know there are missing values in the dataset. Let's find out how many.

```{webr}
#| exercise: ex_1.2.4
#| envir: Ex1
#| warning: false
#| message: false
# Try using sum(is.na()) on the `penguins` dataset.
```

```{webr}
#| exercise: ex_1.2.4
#| solution: true
#| envir: Ex1
# Try using sum(is.na()) on the `penguins` dataset.
sum(is.na(penguins))
```

```{webr}
#| exercise: ex_1.2.4
#| check: true
#| class: wait
#| envir: Ex1
gradethis::grade_this_code()
```

```{r, echo = FALSE, eval=FALSE}
sum(is.na(penguins))
```

There are `r fitb(19)` missing observations. This can cause problems when generating numerical summaries or running statistical tests. At this stage, we address this by removing the missing values. This approach will be discussed in more detail in the next chapter. As a best practice, you should always store your cleaned data in a new dataset and leave the original untouched. **Note that you should always be careful when removing observations, as even partially filled observations can still provide valua**

```{webr}
#| exercise: ex_1.2.5
#| envir: Ex1
#| warning: false
#| message: false
# Use na.omit() on the dataset to remove any missing values. 
# Call this new dataset `clean_penguins` 
clean_penguins <- 
```

```{webr}
#| exercise: ex_1.2.5
#| solution: true
#| envir: Ex1
clean_penguins <- na.omit(penguins)
```

```{webr}
#| exercise: ex_1.2.5
#| check: true
#| class: wait
#| envir: Ex1
gradethis::grade_this_code()
```

```{r, echo= FALSE}
clean_penguins <- na.omit(penguins)
```

We can check the structure again to make sure everything looks good:

```{r}
str(clean_penguins)
```

We can see that there are eight variables. Three of these are categorical: `species`, `island`, and `sex`. These are stored as factors, where the *levels* represent the number of distinct labels or groups within each variable. For example, `sex` has two levels: `male` and `female`.

You'll notice that there are four numerical variables: `bill_length_mm`, `bill_depth_mm`, `flipper_length_mm`, and `year`. If your instinct is that `year` doesn't quite fit as right as a numerical variable, you would be right! It is better to treat `year` as a categorical variable.

How do we manually convert `year` to a factor?

```{webr}
#| exercise: ex_1.2.6
#| envir: Ex1
#| warning: false
#| message: false

```

```{webr}
#| exercise: ex_1.2.6
#| solution: true
#| envir: Ex1
clean_penguins$year <- as.factor(clean_penguins$year)
```

```{webr}
#| exercise: ex_1.2.6
#| check: true
#| class: wait
#| envir: Ex1
gradethis::grade_this_code()
```

```{r, echo=FALSE}
clean_penguins$year <- as.factor(clean_penguins$year)
```

Now if we run `class()`, we can see that `year` is now correctly stored as a categorical variable with three levels.

```{r}
class(clean_penguins$year)
```

How can we check the unique groupings or labels within `year`?

```{webr}
#| exercise: ex_1.2.7
#| envir: Ex1
#| warning: false
#| message: false
# Check the unique groupings or labels within `year`
```

```{webr}
#| exercise: ex_1.2.7
#| solution: true
#| envir: Ex1
unique(clean_penguins$year)
```

```{webr}
#| exercise: ex_1.2.7
#| check: true
#| class: wait
#| envir: Ex1
gradethis::grade_this_code()
```

```{r, echo=FALSE, eval = FALSE}
unique(clean_penguins$year)
```

This shows that the data was collected over the years `r fitb(2007)`, `r fitb(2008)`, and `r fitb(2009)` (ascending order).

You can also see from the structure output `str()` that the `penguins` dataset is stored as a 333 x 8 tibble, which is a type of data frame in R. This means that there are 333 rows (observations) and 8 columns (variables).

Check the dimensions of the cleaned dataset to confirm this.

```{webr}
#| exercise: ex_1.2.8
#| envir: Ex1
#| warning: false
#| message: false
```

```{webr}
#| exercise: ex_1.2.8
#| solution: true
#| envir: Ex1
dim(clean_penguins)
```

```{webr}
#| exercise: ex_1.2.8
#| check: true
#| class: wait
#| envir: Ex1
gradethis::grade_this_code()
```

```{r, echo=FALSE, eval=FALSE}
dim(clean_penguins)
```

If you wish to have a closer look at inspecting the `penguins` dataset, you can use the `View()` function to open it in a new tab on RStudio.

```{r, eval=FALSE}
View(penguins)
View(clean_penguins)
```

### Tables

Now that we've inspected the dataset, we can start thinking about how to visually represent and understand the data.

As we have learnt

```{r, message = FALSE, warning=FALSE}
library(gt)
library(tidyverse)
library(kableExtra)
```

```{r}
naplan %>% 
  dplyr::filter(reading_time_home > 30 & naplan_reading_score > 800) %>%
  gt() %>%
  tab_header(title = "Naplan") %>%
  fmt_number(decimals=2) %>%
  cols_label(
    student_id = md("***Student ID***"),
    school_id = md("***School ID***"),
    grade = md("***Grade***"),
    reading_time_home = md("***Reading Time***"),
    parent_education = md("***Parent Education***"),
    school_type = md("***School Type***"),
    gender = md("***Gender***"),
    birth_months = md("***Birth Month***"),
    n_siblings = md("***Number of Siblings***"),
    ses_index = md("***SES Index***"),
    naplan_reading_score = md("***Reading Score***")
  )
```

```{r}
naplan %>% 
  filter(gender == "Female", school_type == "Independent") %>%
  arrange(desc(naplan_reading_score)) %>%
  slice_head(n = 10) %>%
  gt() %>%
  tab_header(title = "Naplan") %>%
  fmt_number(decimals = 2) %>%
  cols_label(
    student_id = md("***Student ID***"),
    school_id = md("***School ID***"),
    grade = md("***Grade***"),
    reading_time_home = md("***Reading Time***"),
    parent_education = md("***Parent Education***"),
    school_type = md("***School Type***"),
    gender = md("***Gender***"),
    birth_months = md("***Birth Month***"),
    n_siblings = md("***Number of Siblings***"),
    ses_index = md("***SES Index***"),
    naplan_reading_score = md("***Reading Score***")
  ) %>%
  data_color(
    columns = naplan_reading_score,
    method = "numeric",
    palette = "viridis",
    domain = c(0, 1000),
    reverse = TRUE
  ) %>%
  tab_style(
    style = list(
      cell_fill(color = "gray95"),
      cell_borders(sides = c("l", "r"), color = "gray50", weight = px(3))
    ),
    locations = cells_body(columns = -naplan_reading_score)
  ) %>%
  tab_style(
    style = cell_fill(color = "gray98"),
    locations = cells_title()
  ) %>%
  tab_style(
    style = list(cell_fill(color = "gray35"), cell_text(color = "white")),
    locations = list(cells_footnotes(), cells_source_notes())
  ) %>%
  tab_style(
    style = cell_text(weight = "bold"),
    locations = cells_title(groups = "title")
  ) %>% 
  tab_style(
    style = cell_borders(
      sides = c("t", "b"),
      color = "darkgrey",
      weight = px(3)
    ),
    locations = list(cells_column_labels(), cells_stubhead())
  ) %>%
tab_footnote(
    footnote = "SES Index represents ",
    locations = cells_column_labels(columns = ses_index)
  )

```

```{r}
naplan |>
  dplyr::group_by(gender) |>
  dplyr::summarise(
    mean_score = mean(naplan_reading_score, na.rm = TRUE),
    mean_ses   = mean(ses_index, na.rm = TRUE),
    .groups = "drop"
  ) |>
  tidyr::pivot_wider(
    names_from = gender,
    values_from = c(mean_score, mean_ses)
  ) |>
  gt() |>
  fmt_number(columns = everything(), decimals = 2) |>
  tab_spanner(
    label = "Female",
    columns = matches("_Female$")
  ) |>
  tab_spanner(
    label = "Male",
    columns = matches("_Male$")
  ) |>
  cols_label(
    matches("mean_score") ~ "Reading Score<br>Average",
    matches("mean_ses") ~ "SES Index<br>Average",
    .fn=md
  ) |>
  cols_width(everything() ~ px(120))
```

```{r}
library(gtsummary)
```

```{r}
naplan |>
  tbl_summary(
    by = gender,
    include=c(grade, reading_time_home, naplan_reading_score),
    statistic=list(all_continuous()~"{mean} ({sd})"),
    digits=list(naplan_reading_score = c(0,1),
                reading_time_home = c(0,1))
  )
```

```{r}
naplan |>
  tbl_summary(
    include=c(reading_time_home, naplan_reading_score),
    type=all_continuous() ~ "continuous2",
    statistic=list(all_continuous()~c("{median} ({p25}, {p75})", "{min}, {max}"))
    )
```

```{r}
naplan %>%
  filter(gender == "Female", school_type == "Independent") %>%
  arrange(desc(naplan_reading_score)) %>%
  slice_head(n = 10) %>%
  select(
    `Student ID` = student_id,
    `School ID` = school_id,
    Grade = grade,
    `Reading Time` = reading_time_home,
    `Parent Education` = parent_education,
    `School Type` = school_type,
    Gender = gender,
    `Birth Month` = birth_months,
    `Number of Siblings` = n_siblings,
    `SES Index` = ses_index,
    `Reading Score` = naplan_reading_score
  ) %>%
  mutate(
    `Reading Score` = cell_spec(
      `Reading Score`,
      background = spec_color(`Reading Score`, option = "viridis", end = 0.95),
      color = "white"
    )
  ) %>%
  kable(
    format = "html",
    align = "c",
    booktabs = TRUE,
    escape = FALSE,
    caption = "Naplan"
  ) %>%
  kable_styling(full_width = FALSE) %>%
  row_spec(0, bold = TRUE, color = "white", background = "gray35") %>%
  column_spec(
    1:10,
    background = "gray95",
    extra_css = "border-left: 3px solid gray50; border-right: 3px solid gray50;"
  )  %>%  footnote(general = "SES Index represents ...", general_title = "")
```
