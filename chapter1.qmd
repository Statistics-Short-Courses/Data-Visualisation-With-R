---
title: "Getting to Know Your Data"
---

## Variables

Before we jump into the world of statistical testing, let's take a moment to refresh our understanding of what a variable is, the different types of variables, and how we can describe them using numerical and graphical methods.

**So what is a variable?**

The Australian Bureau of Statistics defines a variable to be "any characteristic, number, or quantity that can be measured or counted."

If you've ever tried dieting, you might have recorded your weight on your phone over time. Or maybe you've tracked how long your morning commute takes so you know when to leave to arrive on time. In both cases, you are measuring something that changes, and these are examples of variables.

## Types of Variables

There are two main types of variables:

-   **Numerical**

-   **Categorical**

A **numerical variable** represents values to describe a measurable quantity. A numerical variable can be either **discrete** or **continuous**.

**Discrete numerical variables** take on distinct whole values, and are countable. For example, if we were to look at the at the number of cars in a parking lot, the number of birds in a tree, or the number of times "3" is rolled in a series of die rolls, these are exact values that can be counted and are thus discrete.

**Continuous numerical variables** can take on any value within a range of real numbers. In other words, they can be measured to any level of precision. For example, age exists on a continuous scale because, in theory, it can be measured infinitely precisely. Someone could be 10.25, 10.257, or even 10.2576326362 years old. In everyday life, we usually round age to the nearest year, but that does not change the fact that the underlying variable is continuous. Other common examples of continuous numerical variables include weight, height, and time. Can you explain why each of these variables is numerical and continuous?

A **categorical variable**, on the other hand, represents categories or labels that describe a quality or characteristic. Categorical variables can be either **nominal** or **ordinal**.

A **nominal categorical variable** includes observations with no particular order. For example, if you asked ten coworkers for their favorite movie and recorded their answers under a "movies" variable, it would be nominal because there is no inherent sequence or ranking among the movie titles.

In an **ordinal categorical variable,** there is an inherent logical order to the observations. For example, if we collected age groups such as "18--24", "25--38", "39--55", "56--70", and "70+", we're now working with labels that have a built-in order where "18--24" is younger than "25--38", and so on.

Another example might be asking people whether they like ice cream, with options like "strongly agree", "agree", "neutral", "disagree", and "strongly disagree". In this case, the order of the options has meaning, even if the distance between them isn't equal.

Take a moment to check your understanding with the exercises below.

## Exercise Checkpoint 1

```{r, echo = FALSE}
library(webexercises)
```

1.  **Describe the following variables:**

    a\. Eye colour is a `r mcq(c("discrete numerical variable", "continuous numerical variable", "ordinal categorical variable", answer = "nominal categorical variable"))`

    b\. Temperature is a `r mcq(c("discrete numerical variable", "ordinal categorical variable", "nominal categorical variable", answer = "continuous numerical variable"))`

    c\. The number of heads in a series of coin flips is a `r mcq(c( "continuous numerical variable", "ordinal categorical variable", "nominal categorical variable", answer = "discrete numerical variable"))`

    d\. Education level is a `r mcq(c("discrete numerical variable", "continuous numerical variable", "nominal categorical variable", answer = "ordinal categorical variable"))`

    e\. Postal Code is a `r mcq(c("discrete numerical variable", "continuous numerical variable", "ordinal categorical variable", answer = "nominal categorical variable"))`

    f\. Income salary is a `r mcq(c("discrete numerical variable", "ordinal categorical variable", "nominal categorical variable", answer = "continuous numerical variable"))`

    g\. Number of calls per day is a `r mcq(c("discrete numerical variable", "continuous numerical variable", "ordinal categorical variable", "nominal categorical variable", answer = "discrete numerical variable"))`

## Preparing Data for Visualisation

```{r}
```

```{r}
```

Now that we've covered the main types of variables, we can start thinking about how to prepare and visually represent data with figures and tables. In this section, we will focus on preparing data for tables.

In R, datasets are stored as dataframes, which are objects made up of rows and columns. Each row corresponds to an individual observation, while each column represents the variable that is being measured. There are several ways R stores variables: character for text, factor for categorical, integer for whole numbers, numeric for decimals, and logical for booleans (TRUE/FALSE).

Cleaning data can be the most time-consuming, yet arguably the most important, part of analysing data! Generally, it is

-   wide format to long format

The first data set we will look at today is the Naplan

```{r}
naplan <- read.csv("Data-sets/naplan_reading.csv")
```

Now that we have the dataset loaded in, let's take a look at the variables in the dataset using `str()`.

```{r}
str(naplan)
```

In the top line, we can see that there are 3000 observations and 11 variables.

We can confirm this using the `dim()` function.

```{r}
dim(naplan)
```

```{r}
names(naplan)
```

The first column gives us the variables, the second column gives us the type of variable, and the third column gives us individual observations for each row. However, we can see `school_type` is stored as a `chr` or character (text) variable. Text variables are very common when you encounter surveys that have customer feedback, for example, as each response will be unique from one another.

It is important to check that your variables are stored correctly. We can see certain variables like reading time at home is an integer, which matches our expectations.

You can use the `unique()` function to see the unique groupings or labels within a categorical variable. In our case, we can use it to confirm if our suspicions that `school_type` is categorical. To call a specific variable, we call the dataset followed by `$` and then the variable name.

```{r}
unique(naplan$school_type)
```

There are only 3 unique labels, which strongly suggests that `school type` is a nominal categorical variable. If it were truly a text variable, we might see thousands of unique labels.

We can manually convert the variable to categorical using `as.factor()`:

```{r}
naplan$school_type <- as.factor(naplan$school_type)
```

```{r}
str(naplan)
```

Now we can see `school_type` is a factor with 3 levels (or 3 unique labels).

Alternatively, we can also convert all strings (text) to categorical variables with the `stringsAsFactors` argument when we read in the dataset.

```{r}
naplan <- read.csv("Data-sets/naplan_reading.csv",
                   stringsAsFactors = TRUE)
```

```{r}
str(naplan)
```

As seen above, all the `chr` variables have been converted to `Factor`, which is how the variables should be stored. Note that there might be times where you need a variable stored as `chr`, so you should always be sure of what you're checking.

We can now attach the dataset. Attaching the dataset means we can call variables directly without using `$`.

```{r}
attach(naplan)
```

If we type `naplan` directly in, we can see the content.

```{r}
naplan
```

Alternatively, we can use the `View()` function to open up a new tab in RStudio with the dataset.

```{r,eval=FALSE}
View(naplan)
```

We can also select parts of the dataframe. In R, we subset by calling the dataset followed by `[,]` . Writing a blank space before the comma indicates that all rows are includes, while a blank space after the comma indicates that all columns are included. For example, `[,3]` selects the third column of a dataframe. If we want to select the first three columns, we can write:

```{r}
naplan[,1:3]
```

Perhaps we only want to select the middle rows for all the columns of the dataframe.

```{r}
naplan[5:6,]
```

We can even select rows based on logical tests on the values of one or more variables.

```{r}
naplan[reading_time_home > 30 & naplan_reading_score > 800,]
```

We can also sort the rows and the columns in the dataset. By default, R will sort in ascending order.

```{r}
naplan[order(naplan_reading_score),]
```

We can also sort and select odd numbered columns.

```{r}
naplan[order(naplan_reading_score), c(1, 3, 5, 7, 9, 11)]
```

Or descending order.

```{r}
naplan[rev(order(naplan_reading_score)), c(1, 3, 5, 7, 9, 11)]
```

We can summarise the content of the dataframe as well.

```{r}
summary(naplan)
```

You might notice that the summary doesn't quite work for categorical varibales.

We can use `tapply()` and `with()` to summarise a quantitative variable by a qualitative variable.

```{r}
with(naplan, tapply(naplan_reading_score, grade, mean))
```

`aggregate()` allows you to summarise by one or more categorical variables, while `tapply` can only summarise one variable at a time.

```{r}
aggregate(naplan[,c(4,11)], list(grade),mean)
```

```{r}
aggregate(naplan[,c(4,11)], list(Grade = grade),mean)
```

```{r}
aggregate(naplan[,c(4,11)], list(Grade = grade, "Parent Education" = parent_education),mean)
```

```{r, message = FALSE, warning=FALSE}
library(gt)
library(tidyverse)

```

```{r}
naplan %>% 
  dplyr::filter(reading_time_home > 30 & naplan_reading_score > 800) %>%
  gt() %>%
  tab_header(title = "Naplan") %>%
  fmt_number(decimals=2) %>%
  cols_label(
    student_id = md("***Student ID***"),
    school_id = md("***School ID***"),
    grade = md("***Grade***"),
    reading_time_home = md("***Reading Time***"),
    parent_education = md("***Parent Education***"),
    school_type = md("***School Type***"),
    gender = md("***Gender***"),
    birth_months = md("***Birth Month***"),
    n_siblings = md("***Number of Siblings***"),
    ses_index = md("***SES Index***"),
    naplan_reading_score = md("***Reading Score***")
  )
```

```{r}
naplan %>% 
  filter(gender == "Female", school_type == "Independent") %>%
  arrange(desc(naplan_reading_score)) %>%
  slice_head(n = 10) %>%
  gt() %>%
  tab_header(title = "Naplan") %>%
  fmt_number(decimals = 2) %>%
  cols_label(
    student_id = md("***Student ID***"),
    school_id = md("***School ID***"),
    grade = md("***Grade***"),
    reading_time_home = md("***Reading Time***"),
    parent_education = md("***Parent Education***"),
    school_type = md("***School Type***"),
    gender = md("***Gender***"),
    birth_months = md("***Birth Month***"),
    n_siblings = md("***Number of Siblings***"),
    ses_index = md("***SES Index***"),
    naplan_reading_score = md("***Reading Score***")
  ) %>%
  data_color(
    columns = naplan_reading_score,
    method = "numeric",
    palette = "viridis",
    domain = c(0, 1000),
    reverse = TRUE
  ) %>%
  tab_style(
    style = list(
      cell_fill(color = "gray95"),
      cell_borders(sides = c("l", "r"), color = "gray50", weight = px(3))
    ),
    locations = cells_body(columns = -naplan_reading_score)
  ) %>%
  tab_style(
    style = cell_fill(color = "gray98"),
    locations = cells_title()
  ) %>%
  tab_style(
    style = list(cell_fill(color = "gray35"), cell_text(color = "white")),
    locations = list(cells_footnotes(), cells_source_notes())
  ) %>%
  tab_style(
    style = cell_text(weight = "bold"),
    locations = cells_title(groups = "title")
  ) %>% 
  tab_style(
    style = cell_borders(
      sides = c("t", "b"),
      color = "darkgrey",
      weight = px(3)
    ),
    locations = list(cells_column_labels(), cells_stubhead())
  ) %>%
tab_footnote(
    footnote = "SES Index represents ",
    locations = cells_column_labels(columns = ses_index)
  )

```

```{r}
naplan |>
  dplyr::group_by(gender) |>
  dplyr::summarise(
    mean_score = mean(naplan_reading_score, na.rm = TRUE),
    mean_ses   = mean(ses_index, na.rm = TRUE),
    .groups = "drop"
  ) |>
  tidyr::pivot_wider(
    names_from = gender,
    values_from = c(mean_score, mean_ses)
  ) |>
  gt() |>
  fmt_number(columns = everything(), decimals = 2) |>
  tab_spanner(
    label = "Female",
    columns = matches("_Female$")
  ) |>
  tab_spanner(
    label = "Male",
    columns = matches("_Male$")
  ) |>
  cols_label(
    matches("mean_score") ~ "Reading Score<br>Average",
    matches("mean_ses") ~ "SES Index<br>Average",
    .fn=md
  ) |>
  cols_width(everything() ~ px(120))
```

```{r}
library(psych)


```

Exercise checkpoint

First, we will need to load in some data into R. We will be working with the `palmerpenguins` package. The `palmerpenguins` package is a dataset collected and made available by [Dr. Kristen Gorman](https://www.uaf.edu/cfos/people/faculty/detail/kristen-gorman.php) and the [Palmer Station, Antarctica LTER](https://pallter.marine.rutgers.edu/), a member of the [Long Term Ecological Research Network](https://lternet.edu/).

If you have not used this package before, you will need to install it first:

```{r, eval=FALSE}
install.packages("palmerpenguins")
```

Once installed, you will need to load the package into R.

```{r, warning = FALSE, echo=TRUE, message=FALSE}
library(palmerpenguins)
```

Now that we have the package installed, let's take a look at the variables in the dataset using `str()`.

```{q}
```

You might notice that some values are listed as `NA`. This means there are missing observations. To check for missing values, we can use:

```{r}
any(is.na(penguins))
```

Since this returns `TRUE`, we know there are missing values in the dataset. Let's find out how many:

```{r}
sum(is.na(penguins))
```

There are 19 missing observations. This can cause problems when generating numerical summaries or running statistical tests. At this stage, to handle this, we can remove the missing values. It's always best practice to store your cleaned data in a new dataset and leave the original untouched. **Note that you should always be careful when removing observations, as even partially filled observations can still provide valuable information.**

```{r}
clean_penguins <- na.omit(penguins)
```

We can check the structure again to make sure everything looks good:

```{r}
str(clean_penguins)
```

We can see that there are eight variables. Three of these are categorical: `species`, `island`, and `sex`. These are stored as factors, where the *levels* represent the number of distinct labels or groups within each variable. For example, `sex` has two levels: `male` and `female`.

You'll notice that there are four numerical variables: `bill_length_mm`, `bill_depth_mm`, `flipper_length_mm`, and `year`. If your instinct is that `year` doesn't quite fit as right as a numerical variable, you would be right! It is better to treat `year` as a categorical variable. To convert it, we can use:

```{r}
clean_penguins$year <- as.factor(clean_penguins$year)
```

Now if we run `str` again, we can see that `year` is now correctly stored as a categorical variable with three levels.

```{r}
str(clean_penguins)
```

If you're interested in seeing the unique groupings or labels within a categorical variable, you can use the `unique()` function.

```{r}
unique(clean_penguins$year)
```

This shows that the data was collected over the years 2007, 2008, and 2009.

You can also see from the structure output `str()` that the `penguins` dataset is stored as a 333 x 8 tibble, which is a type of data frame in R. This means that there are 333 rows (observations) and 8 columns (variables).

We can confirm this using the `dim()` function.

```{r}
dim(clean_penguins)
```

If you wish to have a closer look at inspecting the `penguins` dataset, you can use the `View()` function to open it in a new tab on RStudio.

```{r, eval=FALSE}
View(penguins)
View(clean_penguins)
```

Now that we've inspected the dataset, we can start thinking about how to visually represent and understand the data.

```         
```

We can describe data using numerical summaries and graphs. Numerical summaries are statistical measures that capture key aspects of a dataset. The way we choose to present these summaries and the graphs that accompany them depends on the type of variable we are working with.

Let's start with numerical summaries.

For **numerical variables**, whether continuous or discrete, we can include:

-   mean

-   standard deviation

-   median

-   minimum

-   maximum

-   Interquartile Range (IQR)

**IMPORTANT NOTE:** When reporting descriptive statistics, always provide appropriate context. If you report a mean, include the standard deviation, and vice versa. If you report a median, include the interquartile range (IQR), and vice versa. Likewise, if you report a maximum value, always include the minimum to give full perspective.

Some helpful R functions for generating summary statistics:

```{r, warning = FALSE, echo = FALSE}
library(gt)

data <- data.frame(
  "Summary Statistic" = c(
    "Mean",
    "Standard Deviation",
    "Median",
    "Minimum",
    "Maximum",
    "Interquartile Range",
    "First quartile",
    "Third quartile",
    "Five point summary"
  ),
  "Command" = c(
    "mean(...)",
    "sd(...)",
    "median(...)",
    "min(...)",
    "max(...)",
    "IQR(...)",
    "quantile(..., 0.25)",
    "quantile(..., 0.75)",
    "summary(...)"
  ),
  check.names = FALSE
)

gt(data)


```

Let's take a look at calculating descriptive statistics for `body_mass_g`, which describes the body mass of each penguin in grams.

Now we can attach the cleaned `penguins` dataset. Attaching the dataset allows us to call variables directly by name. If we don't attach it, we can still access variables, but we need to use the full format (for example, `clean_penguins$sex`).

```{r, message=F}
# Attach cleaned dataset 
attach(clean_penguins)
```

```{r}
# Let's first calculate the mean and round it to one decimal place
round(mean(body_mass_g),1)

# Now we can calculate the standard deviation
round(sd(body_mass_g),1)
```

The average body mass of penguins is **4207.1 g**, with a standard deviation of **805.2 g**.

```{r}
# calculate the minimum
min(body_mass_g)

# calculate the maximum
max(body_mass_g)
```

The minimum observed body mass is **2700 g**, and the maximum observed body mass is **6300 g**.

```{r}
# calculate median
median(body_mass_g)

# calculate IQR
## first quantile
quantile(body_mass_g, 0.25)
## third quantile 
quantile(body_mass_g, 0.75)
```

The median body mass is **4050 g**, with an interquartile range from **3350 g to 4775 g.**

The `summary()` function lets us quickly gather all of this information at once.

```{r}
# Calculate 5-point summary
summary(body_mass_g)
```
